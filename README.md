This application allows for a partial grain boundary identification. It cannot find all the grain boundaries by itself, so user input through drawing is required to close them. The aim of this is to reduce the time needed to draw the borders, allowing results like grain surface areas to be acquired faster. It uses gradient seeking algorithms to find the borders (where the color value changes by a lot). 

The pipeline followed is:
1) Boundary Seeking Algorithm parameter input window.
2) Scaling factor acquisition (if not given in (1)) via the image and removal of info panel.
3) Pre-processing of the image.
4) Identification of the boundaries and post-processing.
5) Preview of the images given by the gradient seeking function and the post-processing. 
6) Preview of the borders overlayed on the image. Ability to change parameters.
7) Drawing on image and completion of the borders.
8) Measurement algorithm parameter input window.
9) Final preview of borders.
10) Grain identification algorithm.
11) Preview of the identified grains.
12) Calculation of the area of each grain based on the scaling factor.
13) Calculation of the equivalent diameters of each grain and binning them in ranges from the min to the max for histograms.
14) Ellipse fitting on each individual grain to get aspect ratio and directionality.
15) Plotting of aspect ratio histogram and directionality web diagram.
16) Pop up window with some results and a rerun or exit option.
17) If many images have been analyzed via the rerun option, upon exit, a popup window will offer to merge surface and diameter data from all images and make a histogram with all aspect ratios.

Images from steps (6), (7) are being saved as tif images.
Data from steps (12), (13) are being saved in 2 csv files, one containing area and diameter for each grain, the other containing the binned diameters.
Data from step (17) are being saved in the same format.
Data from step (14) are also being saved.

When there is no obvious way to exit a window (button, mentioned keybind) close the window via the window's X top right.

The scaling factor is acquired by drawing a line (left click + drag) on the scale bar of the image and inputting the real length of that bar (press Set Length on the bottom left). Then the division (real length (units))/(line length (pixels)) gives the scaling factor. Pressing shift locks the line horizontal. Panning the image (right click + drag) and zooming is also available (bottom left). Press accept on the bottom right to continue. The info bar might not show up when the window opens. Pan the image in that case.

Pre-processing follows these steps:
1) Gaussian Blur:
This helps suppress dots and speckles that might exist withing the grains. It also makes the color gradients within the grains more uniform so they won't be accidentally identified as borders. The Gaussian blur function used comes from the cv2 Python library.

2) Contrast Enhancement:
Contrast makes grains that have similar colors better "visible" to the algorithm by changing their colors so the grain "closer" to white becomes whiter and the one "closer" to black becomes blacker. cv2's clahe (Contrast Limited Adaptive Histogram Equalization) function is used.

3) Bilateral Blur: 
Contrast enhancement makes regions within grains with different colors that weren't properly smoothed to become more prominent. This blur aims to smooth these regions. The bilateral filter is a gaussian blur that also applies weights to each pixel based on the color difference from the initial pixel. The closer a pixel's color to the initial, the more it'll be blurred.

4) Sobel Gradient:
This algorithm finds the gradients and creates an image of them, which it then blends in the actual image. This helps the algorithm that identifies the boundaries by making some gradients more prominent.

cv2's Canny algorithm is used to find the gradients. It outputs an image of the borders it found. Then, cv2's contour-seeking algorithm finds them in that image and discards those that their size falls under a minimum. After that, a function is applied to try and connect the borders that are broken.

The overlay that appears after allows to change the pre-process and canny related parameters to improve the identified borders and remove noise. The background image can be switched between the original and the pre-processed.

Drawing has the following modes, with their keybinds in parentheses:
1) Drawing (d), where a yellow line is drawn by holding down the left mouse button.
2) Erasing (e), where a black line is drawn by holding down the left mouse button.
3) Undo (u)
4) Redo (r)
5) Increasing (+) or decreasing (-) line thickness.
6) Zooming in and out (scrollwheel or trackpad)
7) Panning (by holding down the right mouse button)
8) Saving the image (s).
9) Quitting drawing (q).

The final preview is black borders on white background. It is generated by taking the drawn image and turning yellow (drawn and identified borders) into black and everything else into white.

The algorithm that finds grains is doing so by looking for connected components. It goes through all pixels of the image. If the pixel is white, it starts a flood-like proccess where it visits all the white pixels neighboring the initial (thus it visits the whole grain that pixel is located into). It then marks the pixels it visited as visited and assigns them all a label (the label of the grain they are located into). It then moves on. If another pixel is white AND not visited, it repeats that proccess.

The grain map that is given in the end presents the grains colored. One can hover above each grain with their mouse to see their label. That way one can tell if 2 or more grains were found as the same grain (they'll have the same label) which means a break in the border.

The calculation of the surfaces uses the pixel count given by the previous algorithm for each grain. The surface is (pixel count)*(scaling factor)^2. 

The grains are considered perfect disks for the diameters to be calculated.

Ellipses and their parameters are found by fitting ellipses on each grain with cv2's ellipse fitting function.


Parameters of the Boundary Seeking Algorithm parameter input window.

1) Pre-Contrast Adjustment Smoothing Parameters (Gaussian):
Smoothing Range (px, px) - The dimensions of the square within which blurring will take place. Many of these squares blur the whole image. The higher the numbers, the bigger the square, offering wider blurring as opposed to more localized for smaller squares.
Standard Deviation (px) - The standard deviation of the Gaussian that handles the blurring. The standard deviation controls the spread of the gaussian. The higher it is, the wider the gaussian is. That means that there is an upper limit to it for the blurring to be effective. This upper limit is controlled by the square. If the square is too small, then the gaussian, which will be wider than it, will not blur efficiently and uniformly. The relation between the 2, if k is the dimension and σ the standard deviation, is σ ≤ (k-1)/6.

2) Contrast Enhancement Parameters:
Intensity - Higher values increase contrast more aggressively, lower values give milder enhancement.
Transitions (px, px) - Higher values create smoother transitions, lower values give more local contrast. 

3) Post-Contrast Adjustment Smoothing Parameters (Bilateral Filter):
Smoothing Range (px) - The range of the blurring. Creates a square with d dimensions (must be odd) and blurring effectively happens in it.
Affected Color Range (gv) - A standard deviation, that determines the color range that will affect the blurring. The further a gray value of a pixel is from the gray value of the center pixel, the lower its weight.
Affected Area Range (px) - A standard deviation that determines the range of the pixels that affect the smoothing that happens within the dxd square. Pixels further than 3*(Affected Area Range) will get a negligible weight. If d = 0, it also handles the smoothing range.

4) Gradient Enhancement Parameters - Boundary Prominence:
Thickness - Higher values produce thicker edges, lower values give finer edges. -1 for Scharr Filter (which is another filter like sobel), use that for faint edges as it detects them better. Key impact: controls edge thickness. Currently doesn't affect the outcome.
Blend Factor (0.0 - 1.0) - Higher values emphasize edges more, lower values keep original image dominant. The factor by which the gradient image by sobel blends to the original.
Gamma - Helps regions with almost identical colors to be contrasted.

5) Canny Parameters:
Canny has 2 thresholds. Threshold 1 (thr1), the low, and threshold 2 (thr2), the high. These 2 thresholds, which are given in gradient units (gray value/pixel, gv/px) create 3 regions. If a detected gradient (dg) falls in dg < thr1, it is dismissed. If it is dg > thr2 is becomes a "strong" border and if it is thr1 < dg < thr2 it is accepted as a border only if it "touches" a strong border.
Canny Threshold 1 - Higher values detect fewer edges, lower values detect more noise as edges.
Canny Threshold 2 - Higher values only keep stronger edges, lower values give more fragmented edges.

6) Gap and Noise Removal
Gap Bridge Parameter - Affects boundary connectivity. Larger values bridge bigger gaps, smaller values keep tighter boundaries. 
Minimum Object Size (px) - Removes items with less than these pixels. Higher values remove more fragments, lower values keep more small edges.


Parameters of the Measurement algorithm parameter input window.
1) Measure Parameters
Grain Minimum Diameter (μm or px) - This controls whether a detected grain will be kept or discared. If a grain is of a diameter less that this, it will be discarded. The unit can be μm or px. The unit is selected using the dropdown window. WARNING!! μm can be selected only if the scaling factor was inputted at the start (filled on the parameters gui or manually inputted).
Scaling Factor (μm/px) - The factor that converts px² to μm² (or any other surface unit, even though the app considers them μm² - just ignore that).

2) Histogram Bin Count - The diameter data will be binned in ranges to then be plotted as a histogram outside this app (e.g. Origin). This parameter determines the number of bins. Each range's width will then be given as width = (max - min)/bin, where min and max the minimum and maximum diameters.


Parameter testing sequence:
Here, as the last part of this small guide, I will talk about the sequence I was changing the parameters when testing on images. 
1st) I started with the contrast parameters, Intensity then Transitions. Contrast is maybe the most important since it makes the grains more prominent for the algorithms to "see".
2nd) Next, the gaussian blur, then the bilateral filter. A good amount of contrast, which detects a lot of grains, came with a lot of noise. So I tried to minimize that noise by adjusting the smoothing parameters.
3rd) The rest pre-proccess parameters, as these offer minor improvements, mostly to close some borders or remove some noise.
4th) Lastly, I played with the Canny parameters, as canny naturally follows pre-processing, it was always the last I edited.
5th) I didn't stop there. After finishing with canny, I tried adjusting the previous parameters, because they could be positively affected by other changes I did.

A small tip: If you find a good parameter combo but wanna keep experimenting, you'll probably note down the parameters. I'd suggest editing the defaults text file, if you don't care for the previous defaults, so you can exit and rerun the app with these.

The code exists in the directory of this app. Make any changes you'd like and rebuild it. I used PyInstaller.
To build, run:
> pyinstaller --onefile --hidden-import=tkinter --hidden-import=matplotlib.backends._backend_tk BarleySieving.py
In the directory BarleySieving.py is located, or 
>pyinstaller --clean BarleySieving.spec
If you kept the .spec file. That will also include the app manifest.